# Projet Web ‚Äì Secure Docs

## Objectif

D√©velopper, par groupe de 3 √† 4 √©tudiants, une plateforme s√©curis√©e de gestion documentaire. Cette plateforme permet √† des utilisateurs authentifi√©s de cr√©er, lire et organiser des documents num√©riques, tout en int√©grant des outils de qualit√© logicielle et de d√©ploiement continu. En fin de TD, une pr√©sentation du projet, des choix d'architecture et une d√©monstration technique sont attendues.

## Pr√©requis techniques

- Utilisation de **Nest.js**
- API construite en **GraphQL (Code First)**
- Int√©gration d'un syst√®me de **Message Queuing** (BullMQ + Redis)
- **Tests automatis√©s** (unitaires et int√©gration)
- **Int√©gration continue (CI)** avec GitHub Actions
- **D√©ploiement avec Docker** (option : Render / Heroku)

## √âtapes de r√©alisation

### 1. √âtude de faisabilit√©

- √âtudier le fonctionnement de NestJS, son installation, son architecture modulaire.
- Analyser les avantages/inconv√©nients de GraphQL dans le contexte d'une API documentaire.
  - [Documentation NestJS](https://docs.nestjs.com/)
  - [Documentation GraphQL](https://graphql.org/)

### 2. Mise en place du projet

- Initialiser le projet avec Nest CLI
- Cr√©er un contr√¥leur Health check r√©pondant "OK"
- Installer Redis via `docker-compose.yml`
- Int√©grer BullMQ pour la gestion asynchrone :
  - Cr√©er une queue
  - Ajouter un job √† partir du contr√¥leur health
  - Cr√©er un consumer
  - Logger le traitement du job
  - [Queues NestJS](https://docs.nestjs.com/techniques/queues)
  - [Redis Docker](https://hub.docker.com/_/redis)

#### Tutoriel de test rapide

```bash
# 1. Lancer Redis (Docker)
docker compose up -d redis

# 2. D√©marrer l'application NestJS en mode d√©veloppement
npm run start:dev

# 3. V√©rifier l'endpoint Health
curl http://localhost:3000/health   # ‚Üí OK

# 4. (Optionnel) Inspecter les jobs dans Redis
docker exec -it secure-docs-redis redis-cli
redis> keys bull:health:*
redis> llen bull:health:completed

# 5. Arr√™ter les services
Ctrl+C   # pour arr√™ter NestJS
docker compose down  # pour arr√™ter Redis
```

### 3. Configuration GraphQL

- Installer `@nestjs/graphql`
- Configurer GraphQL en mode Code First
- Ajouter un premier r√©solveur retournant `{ result: "ok" }`
- Tester l'API avec Postman ou GraphQL Playground
  - [Quick Start GraphQL NestJS](https://docs.nestjs.com/graphql/quick-start)

#### Tester GraphQL

1. S'assurer que l'application tourne (`npm run start:dev`).
2. Ouvrir le Playground : http://localhost:3000/graphql
3. Lancer la requ√™te suivante :

```graphql
query {
  result
}
```

Vous devriez obtenir :

```json
{
  "data": {
    "result": "ok"
  }
}
```

### 4. üîê Authentification et S√©curit√©

- **JWT Authentication** avec Passport.js
- **Protection des routes** GraphQL avec guards
- **Gestion des r√¥les** (ADMIN, USER)
- **Hachage s√©curis√©** des mots de passe avec bcrypt

#### Configuration rapide

```bash
# Les d√©pendances sont d√©j√† install√©es
# Configurer la variable d'environnement
echo "JWT_SECRET=votre-cl√©-secr√®te-jwt-tr√®s-longue-et-complexe" >> .env
```

#### Tests d'authentification

1. **Script de test automatique :**

```bash
# Depuis la racine du projet
node src/auth/test-auth.script.js
```

2. **Test manuel dans GraphQL Playground :**

```graphql
# 1. Se connecter avec l'admin par d√©faut
mutation {
  login(loginInput: { email: "admin@example.com", password: "password" }) {
    access_token
    user {
      id
      email
      username
      role
    }
  }
}

# 2. Utiliser le token dans les headers pour les queries prot√©g√©es
# Headers: { "Authorization": "Bearer <votre_token>" }
query {
  me {
    id
    email
    username
    role
  }
}

# 3. Tester l'inscription
mutation {
  register(
    registerInput: {
      email: "nouveau@example.com"
      username: "nouveau_user"
      password: "motdepasse123"
      role: USER
    }
  ) {
    access_token
    user {
      id
      email
      username
      role
    }
  }
}
```

#### Comptes par d√©faut

| Email             | Mot de passe | R√¥le  |
| ----------------- | ------------ | ----- |
| admin@example.com | password     | ADMIN |
| user@example.com  | password     | USER  |

#### Routes prot√©g√©es

- **USER** : `me`, `getDocumentsByUser`, `createDocument`, `updateDocument`, `deleteDocument`
- **ADMIN** : `users`, `documents`, `createUser`, `deleteUser`

üìö **Documentation compl√®te :** [src/auth/README.md](src/auth/README.md)

### 5. Conception de l'architecture

- Mod√©liser les entit√©s :
  - Utilisateur
  - Document
  - (optionnel) Historique ou Log
- Organiser le projet :
  - Mod√®les / DTO / services / r√©solveurs
  - Gestion des r√¥les : admin, user
  - [Exemple de projet](https://github.com/nestjs/nest/tree/master/sample/23-graphql-code-first)

#### Tests de v√©rification de l'√©tape 4

Apr√®s avoir impl√©ment√© l'architecture, v√©rifiez que tout fonctionne :

1. **D√©marrer l'environnement :**

```bash
# D√©marrer Redis
docker compose up -d redis

# D√©marrer l'application
npm run start:dev
```

2. **V√©rifier le sch√©ma GraphQL :**

   - Le fichier `src/schema.gql` doit contenir les types `User`, `Document` et les enums `UserRole`
   - Ouvrir GraphQL Playground : http://localhost:3000/graphql

3. **Tests des queries de base :**

```graphql
# Test 1 : Ping original (√©tape 3)
query {
  result
}

# Test 2 : Lister tous les utilisateurs
query {
  users {
    id
    email
    username
    role
    createdAt
  }
}

# Test 3 : R√©cup√©rer un utilisateur par ID
query {
  user(id: "1") {
    id
    email
    username
    role
  }
}

# Test 4 : Lister tous les documents
query {
  documents {
    id
    title
    description
    fileUrl
    userId
  }
}

# Test 5 : Documents par utilisateur (API requise)
query {
  getDocumentsByUser(userId: "1") {
    id
    title
    description
    userId
  }
}

# Test 6 : Document par ID (API requise)
query {
  getDocumentById(id: "1") {
    id
    title
    description
    fileUrl
    userId
  }
}
```

4. **Tests des mutations :**

```graphql
# Test 7 : Cr√©er un utilisateur
mutation {
  createUser(
    createUserInput: {
      email: "test@example.com"
      username: "testuser"
      role: USER
    }
  ) {
    id
    email
    username
    role
  }
}

# Test 8 : Cr√©er un document (API requise)
mutation {
  createDocument(
    createDocumentInput: {
      title: "Document de test"
      description: "Ceci est un test"
      fileUrl: "https://example.com/test.pdf"
      userId: "1"
    }
  ) {
    id
    title
    description
    fileUrl
    userId
  }
}

# Test 9 : Supprimer un document (API requise)
mutation {
  deleteDocument(id: "2")
}

# Test 10 : Mettre √† jour un document
mutation {
  updateDocument(id: "1", updateDocumentInput: { title: "Titre modifi√©" }) {
    id
    title
    description
  }
}
```

#### Tests automatis√©s e2e (End-to-End)

En plus des tests manuels dans GraphQL Playground, des **tests automatis√©s** ont √©t√© cr√©√©s pour valider l'√©tape 4.

**Comment lancer les tests e2e :**

```bash
# Lancer tous les tests e2e
npm run test:e2e
```

**Ce qui est test√© automatiquement :**

1. **`test/app.e2e-spec.ts`** : Test de base (GET /)
2. **`test/health.e2e-spec.ts`** : Endpoint Health + BullMQ (√©tape 2)
3. **`test/graphql.e2e-spec.ts`** : Toutes les APIs GraphQL (√©tape 4)
   - Ping original (√©tape 3)
   - CRUD Users complet
   - CRUD Documents avec APIs requises
   - Validation des enums UserRole
   - 11 tests couvrant tous les cas d'usage

**R√©sultats attendus :**

```
Test Suites: 3 passed, 3 total
Tests:       14 passed, 14 total
```

**Note :** Le warning "_worker process has failed to exit gracefully_" est normal avec NestJS + GraphQL + BullMQ et n'affecte pas le fonctionnement.

**‚úÖ Si tous les tests passent, les √©tapes 2, 3 et 4 sont enti√®rement valid√©es !**

### 5. D√©veloppement des APIs

- R√©solveurs :
  - `getDocumentsByUser()` - Impl√©ment√© et test√©
  - `getDocumentById()` - Impl√©ment√© et test√©
- Mutations :
  - `createDocument(title, description, fileUrl)` - Impl√©ment√© et test√©
  - `deleteDocument(id)` - Impl√©ment√© et test√©
  - (bonus) `updateDocument()` - Impl√©ment√© et test√©
- Donn√©es stock√©es en m√©moire dans un premier temps

**Toutes les APIs sont fonctionnelles et test√©es automatiquement via les tests e2e.**

### 6. Int√©gration du Message Queuing

- Lors de la cr√©ation ou suppression d'un document :
  - Envoyer un √©v√©nement dans une queue
  - Le consumer loggue et traite l'√©v√©nement (audit, analytics, etc.)

#### Tester le queuing BullMQ (documents et utilisateurs)

1. **Lancer l'environnement**

```bash
# Lancer Redis (Docker)
docker compose up -d redis

# D√©marrer l'application NestJS en mode d√©veloppement
npm run start:dev
```

2. **Cr√©er ou supprimer un document OU un utilisateur**

- Ouvre GraphQL Playground : http://localhost:3000/graphql
- Utilise les mutations suivantes :

#### üîπ **Mutations pour les UTILISATEURS** (queue: `user-events`)

**Cr√©er un utilisateur :**

```graphql
mutation {
  createUser(
    createUserInput: {
      email: "test@example.com"
      username: "testuser"
      role: USER
    }
  ) {
    id
    email
    username
    role
    createdAt
  }
}
```

**Supprimer un utilisateur :**

```graphql
mutation {
  deleteUser(id: "3") # remplacez par l'ID de l'utilisateur cr√©√©
}
```

#### üîπ **Mutations pour les DOCUMENTS** (queue: `document-events`)

**Cr√©er un document :**

```graphql
mutation {
  createDocument(
    createDocumentInput: {
      title: "Document de test BullMQ"
      description: "Test de la queue document-events"
      fileUrl: "https://example.com/test.pdf"
      userId: "1"
    }
  ) {
    id
    title
    description
    fileUrl
    userId
    createdAt
  }
}
```

**Supprimer un document :**

```graphql
mutation {
  deleteDocument(id: "3") # remplacez par l'ID du document cr√©√©
}
```

3. **Observer la console du backend**

- Lors de la cr√©ation/suppression d'un **document**, tu dois voir :
  - `Event re√ßu dans la queue document-events: { action: 'create', documentId: 'X', timestamp: ... }`
  - `Event re√ßu dans la queue document-events: { action: 'delete', documentId: 'X', timestamp: ... }`
- Lors de la cr√©ation/suppression d'un **utilisateur**, tu dois voir :
  - `Event re√ßu dans la queue user-events: { action: 'create', userId: 'Y', timestamp: ... }`
  - `Event re√ßu dans la queue user-events: { action: 'delete', userId: 'Y', timestamp: ... }`

#### üß™ **S√©quence de test compl√®te**

```graphql
# Test 1: Cr√©er un utilisateur
mutation {
  createUser(
    createUserInput: {
      email: "bullmq@test.com"
      username: "bullmqtest"
      role: USER
    }
  ) {
    id
    email
  }
}

# Test 2: Cr√©er un document
mutation {
  createDocument(
    createDocumentInput: {
      title: "Test BullMQ"
      description: "Queue test"
      userId: "1"
    }
  ) {
    id
    title
  }
}

# Test 3: Supprimer le document cr√©√© (remplacez l'ID)
mutation {
  deleteDocument(id: "3")
}

# Test 4: Supprimer l'utilisateur cr√©√© (remplacez l'ID)
mutation {
  deleteUser(id: "3")
}
```

#### üîç **V√©rification avanc√©e avec Redis CLI** (optionnel)

```bash
# Acc√©der √† Redis CLI
docker exec -it secure-docs-redis redis-cli

# V√©rifier les queues
redis> keys bull:*
redis> llen bull:user-events:completed
redis> llen bull:document-events:completed
```

**‚úÖ Si vous voyez ces logs dans votre console, BullMQ est correctement configur√© et fonctionne !**

### 7. Int√©gration continue

- Cr√©er un d√©p√¥t GitHub
- Configurer une GitHub Action :
  - `npm install`
  - `npm run lint`
  - `npm run test`
  - `nest build`
- Cr√©er une image Docker
- La tester localement
- Modifier l'action GitHub pour builder l'image
  - [GitHub Actions](https://github.com/features/actions)

#### üê≥ **Cr√©ation et test de l'image Docker**

**1. Dockerfile cr√©√©** avec optimisations :

- Build multi-stage (r√©duction de la taille)
- Image Alpine (l√©g√®re)
- Utilisateur non-root (s√©curit√©)
- Cache optimis√©

**2. Tester l'image localement :**

```bash
# M√©thode 1: Construction manuelle
docker build -t secure-docs:latest .
docker run --name test-secure-docs -p 3001:3000 -d secure-docs:latest
curl http://localhost:3001  # ‚Üí Hello World!
curl http://localhost:3001/health  # ‚Üí OK
docker stop test-secure-docs && docker rm test-secure-docs

# M√©thode 2: Script automatis√©
./scripts/test-docker.sh

# M√©thode 3: Docker Compose complet (avec Redis)
docker-compose -f docker-compose.test.yml up --build
```

#### üîÑ **GitHub Actions CI/CD Pipeline**

**Workflow cr√©√©** (`.github/workflows/ci.yml`) qui :

**Job 1 - Tests et Qualit√© :**

- ‚úÖ Installation des d√©pendances (`npm ci`)
- ‚úÖ Linter ESLint (`npm run lint`)
- ‚úÖ Tests unitaires (`npm run test`)
- ‚úÖ Tests e2e (`npm run test:e2e`)
- ‚úÖ Build de l'application (`npm run build`)
- ‚úÖ Service Redis pour les tests

**Job 2 - Docker Build & Push :**

- ‚úÖ Build de l'image Docker
- ‚úÖ Push vers DockerHub (sur `main` uniquement)
- ‚úÖ Tagging automatique (latest, sha, branch)
- ‚úÖ Cache optimis√© GitHub Actions
- ‚úÖ Scan de vuln√©rabilit√©s avec Docker Scout

#### üß™ **Tests d'int√©gration automatis√©s**

```bash
# Tester localement avec Docker Compose
docker-compose -f docker-compose.test.yml up --build

# V√©rifier les endpoints
curl http://localhost:3000  # API de base
curl http://localhost:3000/health  # Health check
curl -X POST -H "Content-Type: application/json" \
  -d '{"query":"{ result }"}' \
  http://localhost:3000/graphql  # GraphQL
```

**‚úÖ Pipeline compl√®te :** Tests ‚Üí Build ‚Üí Push ‚Üí Deploy ready!

### 8. Tests automatis√©s ‚úÖ **COMPL√âT√â**

#### üß™ **Tests unitaires impl√©ment√©s**

**Jest** √©tait d√©j√† install√© et configur√©. Nous avons cr√©√© des tests complets pour :

**Tests des services :**

- `src/user/user.service.spec.ts` (29 tests)
- `src/document/document.service.spec.ts` (16 tests)

**Tests des r√©solveurs :**

- `src/user/user.resolver.spec.ts` (13 tests)
- `src/document/document.resolver.spec.ts` (14 tests)

#### üìä **Couverture de code**

```bash
# Lancer tous les tests
npm test

# Tests avec couverture
npm run test:cov
```

**R√©sultats :**

- **62 tests** unitaires passent tous
- **Couverture globale :** 65.94%
- **Services :** 100% de couverture
- **R√©solveurs :** ~80% de couverture

#### üîß **Types de tests couverts**

- ‚úÖ Tests unitaires des services (CRUD, validation)
- ‚úÖ Tests unitaires des r√©solveurs (GraphQL)
- ‚úÖ Tests avec mocks (BullMQ, services)
- ‚úÖ Tests de gestion d'erreurs
- ‚úÖ Tests de validation des donn√©es
- ‚úÖ Tests d'int√©gration comportementale
- ‚úÖ **Tests d'authentification** (JWT, passwords, s√©curit√©)

#### üîê **Tests d'authentification**

**Tests d'int√©gration AuthService :**

```bash
# Tests Jest sp√©cialis√©s pour l'authentification
npm test -- auth.integration.spec.ts
```

**Script de test manuel GraphQL :**

```bash
# Test complet du workflow d'authentification
node src/auth/test-auth.script.js
```

**Tests couverts :**

- ‚úÖ Validation utilisateur (email/password)
- ‚úÖ Login avec identifiants valides/invalides
- ‚úÖ Inscription de nouveaux utilisateurs
- ‚úÖ Hachage s√©curis√© des mots de passe
- ‚úÖ G√©n√©ration et validation de tokens JWT
- ‚úÖ S√©curit√© (pas d'exposition des passwords)
- ‚úÖ Routes prot√©g√©es avec guards

**Documentation :** [Testing NestJS](https://docs.nestjs.com/fundamentals/testing) | [Tests Auth](src/auth/README.md#tests)

### 9. D√©ploiement continu ‚úÖ **COMPL√âT√â**

- Modifier la GitHub Action pour :
  - ‚úÖ Pousser l'image Docker sur DockerHub [Lien DockerHub](https://hub.docker.com/r/troxydev/secure-docs)
  - ‚úÖ D√©ployer automatiquement via Render ou Heroku √† chaque push sur main [D√©ploiement Render](https://projetweb-efrei.onrender.com/)

### 10. Tests d'int√©gration ‚úÖ **COMPL√âT√â**

- ‚úÖ Cr√©er une collection Postman pour tester les APIs [Collection Postman](https://sofianefares.postman.co/workspace/e649fe57-d047-469c-840c-e02347de9ae9/collection/46300404-f9c3ead2-d286-44c8-a499-2a36fcf61213?action=share&source=copy-link&creator=46300404)
- Automatiser ces tests avec Newman
- Les int√©grer dans la pipeline GitHub Actions

### 11. Interface utilisateur (bonus recommand√©)

- Afficher la liste des documents de l'utilisateur
- Afficher les d√©tails d'un document
- Cr√©er et supprimer un document via l'UI
- Framework libre : React, Vue, Angular...

### 12. Authentification ‚úÖ **COMPL√âT√â**

- Utiliser une librairie comme Auth0 ou Passport.js avec JWT
- Prot√©ger les routes sensibles
- Associer les documents √† l'utilisateur authentifi√©
  - [Auth0](https://developer.auth0.com/)

### 13. Gestion de fichiers (bonus)

- Impl√©menter l'upload de fichier
- Stocker localement (dans `/uploads`) ou utiliser un cloud storage
- Lier chaque document √† une URL de fichier

### 14. Base de donn√©es

- Int√©grer Prisma et une base PostgreSQL
- Modifier les services pour stocker les documents et utilisateurs en base
- D√©ployer la base sur Render PostgreSQL
  - [Prisma](https://www.prisma.io/docs)
